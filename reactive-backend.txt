
--- FILE: pom.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.6</version>
        <relativePath/>
    </parent>
    
    <groupId>com.yowyob</groupId>
    <artifactId>reactive-hexagonal</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>reactive-hexagonal</name>
    <description>Template Hexagonal Reactive pour com.yowyob</description>
    
    <properties>
        <java.version>21</java.version>
        <spring-cloud.version>2023.0.0</spring-cloud.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
    </properties>
    
    <dependencies>
        <!-- REACTIVE CORE -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- DATA (R2DBC & REDIS) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-r2dbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>r2dbc-postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
        </dependency>

        <!-- MESSAGING (KAFKA) -->
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>io.projectreactor.kafka</groupId>
            <artifactId>reactor-kafka</artifactId>
            <version>1.3.22</version>
        </dependency>

        <!-- CLOUD & RESILIENCE -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
        </dependency>

        <!-- TOOLS (Lombok & Mapstruct) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>
        
        <!-- Docker Compose Auto-setup -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-docker-compose</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.30</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

--- FILE: compose.yaml ---


--- FILE: src/main/java/com/yowyob/template/TemplateApplication.java ---
package com.yowyob.template;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TemplateApplication {

	public static void main(String[] args) {
		SpringApplication.run(TemplateApplication.class, args);
	}

}


--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/outbound/messaging/KafkaAdapter.java ---
package com.yowyob.template.infrastructure.adapters.outbound.messaging;

import com.yowyob.template.domain.model.Product;
import com.yowyob.template.domain.ports.out.ProductEventPublisherPort;
import lombok.RequiredArgsConstructor;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.core.reactive.ReactiveKafkaProducerTemplate;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Component
@RequiredArgsConstructor
public class KafkaAdapter implements ProductEventPublisherPort {

    private final ReactiveKafkaProducerTemplate<String, Object> kafkaTemplate;

    @Value("${application.kafka.topics.product-events}")
    private String productEventsTopic;

    @Override
    public Mono<Void> publishProductCreated(Product product) {
        return kafkaTemplate.send(productEventsTopic, product.id().toString(), product)
                .then();
    }
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/outbound/persistence/PostgresR2dbcAdapter.java ---
package com.yowyob.template.infrastructure.adapters.outbound.persistence;

import com.yowyob.template.domain.model.Product;
import com.yowyob.template.domain.ports.out.ProductRepositoryPort;
import com.yowyob.template.infrastructure.adapters.outbound.persistence.repository.ProductR2dbcRepository;
import com.yowyob.template.infrastructure.mappers.ProductMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Component
@RequiredArgsConstructor
public class PostgresR2dbcAdapter implements ProductRepositoryPort {

    private final ProductR2dbcRepository repository;
    private final ProductMapper mapper;

    @Override
    public Mono<Product> save(Product product) {
        return repository.save(mapper.toEntity(product))
                .map(mapper::toDomain);
    }
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/outbound/persistence/repository/ProductR2dbcRepository.java ---
package com.yowyob.template.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.template.infrastructure.adapters.outbound.persistence.entity.ProductEntity;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import java.util.UUID;

public interface ProductR2dbcRepository extends ReactiveCrudRepository<ProductEntity, UUID> {}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/outbound/persistence/entity/ProductEntity.java ---
package com.yowyob.template.infrastructure.adapters.outbound.persistence.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;
import java.math.BigDecimal;
import java.util.UUID;

@Table("products")
@Data @NoArgsConstructor @AllArgsConstructor
public class ProductEntity {
    @Id
    private UUID id;
    private String name;
    private BigDecimal price;
    private String status;
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/outbound/cache/RedisAdapter.java ---
package com.yowyob.template.infrastructure.adapters.outbound.cache;

import com.yowyob.template.domain.model.Product;
import com.yowyob.template.domain.ports.out.ProductCachePort;
import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;
import java.time.Duration;

@Component
@RequiredArgsConstructor
public class RedisAdapter implements ProductCachePort {
    private final ReactiveRedisTemplate<String, Object> redisTemplate;

    @Override
    public Mono<Boolean> saveInCache(Product product) {
        return redisTemplate.opsForValue()
                .set("product:" + product.id(), product, Duration.ofMinutes(10));
    }
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/outbound/external/StockAdapter.java ---
package com.yowyob.template.infrastructure.adapters.outbound.external;

import com.yowyob.template.domain.ports.out.StockClientPort;
import com.yowyob.template.infrastructure.adapters.outbound.external.client.StockApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.client.circuitbreaker.ReactiveCircuitBreaker;
import org.springframework.cloud.client.circuitbreaker.ReactiveCircuitBreakerFactory;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Component
@Slf4j
@RequiredArgsConstructor
public class StockAdapter implements StockClientPort {

    private final StockApiClient client;
    private final ReactiveCircuitBreakerFactory<?, ?> cbFactory;

    @Override
    public Mono<Boolean> isStockFull(String productName) {
        ReactiveCircuitBreaker rcb = cbFactory.create("stock-service");

        return rcb.run(
                client.checkStock(productName).map(StockApiClient.StockResponse::full),
                throwable -> fallbackStockCheck(productName, throwable)
        );
    }

    private Mono<Boolean> fallbackStockCheck(String productName, Throwable t) {
        log.warn("Circuit Breaker open or Service Down for {}. Error: {}", productName, t.getMessage());
        // Fallback: if the service is down, consider the stock not full
        return Mono.just(false);
    }
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/outbound/external/client/StockApiClient.java ---
package com.yowyob.template.infrastructure.adapters.outbound.external.client;

import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.service.annotation.GetExchange;
import org.springframework.web.service.annotation.HttpExchange;
import reactor.core.publisher.Mono;

@HttpExchange("/api/stock")
public interface StockApiClient {
    @GetExchange("/check")
    Mono<StockResponse> checkStock(@RequestParam("name") String name);

    record StockResponse(boolean full) {}
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/inbound/rest/GlobalExceptionHandler.java ---
package com.yowyob.template.infrastructure.adapters.inbound.rest;

import com.yowyob.template.domain.exception.StockFullException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.net.URI;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(StockFullException.class)
    public ProblemDetail handleStockException(StockFullException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(HttpStatus.CONFLICT, ex.getMessage());
        problem.setTitle("Stock Overflow");
        problem.setType(URI.create("errors/stock-full"));
        return problem;
    }
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/inbound/rest/ProductController.java ---
package com.yowyob.template.infrastructure.adapters.inbound.rest;

import com.yowyob.template.domain.ports.in.CreateProductUseCase;
import com.yowyob.template.infrastructure.adapters.inbound.rest.dto.ProductRequest;
import com.yowyob.template.infrastructure.adapters.inbound.rest.dto.ProductResponse;
import com.yowyob.template.infrastructure.mappers.ProductMapper;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/v1/products")
@RequiredArgsConstructor
public class ProductController {

    private final CreateProductUseCase useCase;
    private final ProductMapper mapper;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<ProductResponse> create(@RequestBody @Valid Mono<ProductRequest> requestMono) {
        return requestMono
                .map(mapper::toDomain)
                .flatMap(useCase::createProduct)
                .map(mapper::toResponse);
    }
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/inbound/rest/dto/ProductRequest.java ---
package com.yowyob.template.infrastructure.adapters.inbound.rest.dto;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Positive;
import java.math.BigDecimal;


public record ProductRequest(@NotBlank String name, @Positive BigDecimal price) {}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/inbound/rest/dto/ProductResponse.java ---
package com.yowyob.template.infrastructure.adapters.inbound.rest.dto;
import java.math.BigDecimal;
import java.util.UUID;


public record ProductResponse(UUID id, String name, BigDecimal price, String status) {}

--- FILE: src/main/java/com/yowyob/template/infrastructure/adapters/inbound/kafka/ProductEventConsumer.java ---
package com.yowyob.template.infrastructure.adapters.inbound.kafka;

import com.yowyob.template.domain.model.Product;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class ProductEventConsumer {

    @Value("${application.kafka.topics.product-events}")
    private String productEventsTopic;

    @KafkaListener(topics = "${application.kafka.topics.product-events}", groupId = "template-group")
    public void consume(Product product) {
        log.info("CONSUMER: I received an event for product with id : {} and price : {}", 
                 product.name(), product.price());
    }
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/mappers/ProductMapper.java ---
package com.yowyob.template.infrastructure.mappers;

import com.yowyob.template.domain.model.Product;
import com.yowyob.template.infrastructure.adapters.inbound.rest.dto.ProductRequest;
import com.yowyob.template.infrastructure.adapters.inbound.rest.dto.ProductResponse;
import com.yowyob.template.infrastructure.adapters.outbound.persistence.entity.ProductEntity;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface ProductMapper {
    Product toDomain(ProductRequest request);
    ProductResponse toResponse(Product domain);
    
    ProductEntity toEntity(Product domain);
    Product toDomain(ProductEntity entity);
}

--- FILE: src/main/java/com/yowyob/template/infrastructure/config/KafkaConfig.java ---
package com.yowyob.template.infrastructure.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.reactive.ReactiveKafkaProducerTemplate;
import reactor.kafka.sender.SenderOptions;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public ReactiveKafkaProducerTemplate<String, Object> reactiveKafkaProducerTemplate() {
        Map<String, Object> props = new HashMap<>();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, org.springframework.kafka.support.serializer.JsonSerializer.class);

        SenderOptions<String, Object> senderOptions = SenderOptions.create(props);

        return new ReactiveKafkaProducerTemplate<>(senderOptions);
    }
}


--- FILE: src/main/java/com/yowyob/template/infrastructure/config/DatabaseInitConfig.java ---
package com.yowyob.template.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.r2dbc.core.DatabaseClient;
import jakarta.annotation.PostConstruct;
import reactor.core.publisher.Flux;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.stream.Collectors;

@Configuration
public class DatabaseInitConfig {

    private final DatabaseClient databaseClient;

    public DatabaseInitConfig(DatabaseClient databaseClient) {
        this.databaseClient = databaseClient;
    }

    @PostConstruct
    public void init() throws Exception {
        ClassPathResource resource = new ClassPathResource("schema.sql");
        String sql = Files.lines(Paths.get(resource.getURI()))
                          .collect(Collectors.joining("\n"));

        String[] statements = sql.split(";");

        Flux.fromArray(statements)
            .map(String::trim)
            .filter(s -> !s.isEmpty())
            .flatMap(s -> databaseClient.sql(s).then())
            .subscribe(
                null,
                err -> System.err.println("Erreur lors de l'init DB : " + err),
                () -> System.out.println("Base initialisée avec succès")
            );
    }
}


--- FILE: src/main/java/com/yowyob/template/infrastructure/config/RedisConfig.java ---
package com.yowyob.template.infrastructure.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.module.paramnames.ParameterNamesModule;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.ReactiveRedisConnectionFactory;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.data.redis.serializer.*;

@Configuration
public class RedisConfig {

    @Bean
    public ReactiveRedisTemplate<String, Object> reactiveRedisTemplate(
            ReactiveRedisConnectionFactory factory) {

        ObjectMapper mapper = new ObjectMapper()
                .registerModule(new ParameterNamesModule())
                .registerModule(new JavaTimeModule());

        Jackson2JsonRedisSerializer<Object> jsonSerializer =
                new Jackson2JsonRedisSerializer<>(mapper, Object.class);

        RedisSerializationContext<String, Object> context =
                RedisSerializationContext.<String, Object>newSerializationContext(new StringRedisSerializer())
                        .value(jsonSerializer)
                        .hashValue(jsonSerializer)
                        .build();

        return new ReactiveRedisTemplate<>(factory, context);
    }
}


--- FILE: src/main/java/com/yowyob/template/infrastructure/config/WebClientConfig.java ---
package com.yowyob.template.infrastructure.config;

import com.yowyob.template.infrastructure.adapters.outbound.external.client.StockApiClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.support.WebClientAdapter;
import org.springframework.web.service.invoker.HttpServiceProxyFactory;

@Configuration
public class WebClientConfig {

    @Bean
    public StockApiClient stockApiClient(WebClient.Builder builder, 
                                         @Value("${application.external.stock-service-url}") String url) {
                                            
        WebClient webClient = builder.baseUrl(url).build();
        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        HttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(adapter).build();
        
        return factory.createClient(StockApiClient.class);
    }
}

--- FILE: src/main/java/com/yowyob/template/domain/exception/StockFullException.java ---
package com.yowyob.template.domain.exception;

public class StockFullException extends RuntimeException {
    public StockFullException(String message) {
        super(message);
    }
}

--- FILE: src/main/java/com/yowyob/template/domain/ports/in/CreateProductUseCase.java ---
package com.yowyob.template.domain.ports.in;

import com.yowyob.template.domain.model.Product;
import reactor.core.publisher.Mono;

public interface CreateProductUseCase {
    Mono<Product> createProduct(Product product);
}

--- FILE: src/main/java/com/yowyob/template/domain/ports/out/ProductEventPublisherPort.java ---
package com.yowyob.template.domain.ports.out;

import com.yowyob.template.domain.model.Product;
import reactor.core.publisher.Mono;

public interface ProductEventPublisherPort {
    Mono<Void> publishProductCreated(Product product);
}

--- FILE: src/main/java/com/yowyob/template/domain/ports/out/StockClientPort.java ---
package com.yowyob.template.domain.ports.out;

import reactor.core.publisher.Mono;

public interface StockClientPort {
    /**
     * Verify if te stock is full.
     * @return true full, false otherwise
     */
    Mono<Boolean> isStockFull(String productName);
}

--- FILE: src/main/java/com/yowyob/template/domain/ports/out/ProductRepositoryPort.java ---
package com.yowyob.template.domain.ports.out;

import com.yowyob.template.domain.model.Product;
import reactor.core.publisher.Mono;

public interface ProductRepositoryPort {
    Mono<Product> save(Product product);
}

--- FILE: src/main/java/com/yowyob/template/domain/ports/out/ProductCachePort.java ---
package com.yowyob.template.domain.ports.out;

import com.yowyob.template.domain.model.Product;
import reactor.core.publisher.Mono;

public interface ProductCachePort {
    Mono<Boolean> saveInCache(Product product);
}

--- FILE: src/main/java/com/yowyob/template/domain/model/Product.java ---
package com.yowyob.template.domain.model;

import java.math.BigDecimal;
import java.util.UUID;

public record Product(UUID id, String name, BigDecimal price, String status) {}

--- FILE: src/main/java/com/yowyob/template/application/service/ProductService.java ---
package com.yowyob.template.application.service;

import com.yowyob.template.domain.exception.StockFullException;
import com.yowyob.template.domain.model.Product;
import com.yowyob.template.domain.ports.in.CreateProductUseCase;
import com.yowyob.template.domain.ports.out.ProductCachePort;
import com.yowyob.template.domain.ports.out.ProductEventPublisherPort;
import com.yowyob.template.domain.ports.out.ProductRepositoryPort;
import com.yowyob.template.domain.ports.out.StockClientPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

// import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class ProductService implements CreateProductUseCase {

    private final ProductRepositoryPort repository;
    private final StockClientPort stockClient;
    private final ProductCachePort cache;
    private final ProductEventPublisherPort publisher;

    @Override
    public Mono<Product> createProduct(Product product) {
        return stockClient.isStockFull(product.name())
                .flatMap(isFull -> {
                    if (isFull) {
                        return Mono.error(new StockFullException("Stock is full for the product : " + product.name()));
                    }
                    return Mono.just(product);
                })
                .map(p -> new Product(null, p.name(), p.price(), "CREATED"))
                .flatMap(repository::save)
                .flatMap(savedProduct -> 
                    // We cache and publish asynchronously, then return the object
                    Mono.when(
                        cache.saveInCache(savedProduct),
                        publisher.publishProductCreated(savedProduct)
                    ).thenReturn(savedProduct)
                )
                .doOnSuccess(p -> log.info("Product successfully created : {}", p.id()));
    }
}

--- FILE: src/main/resources/prod.application.yml ---
server:
  port: 8080

spring:
  application:
    name: reactive-hexagonal
    
  docker:
    compose:
      enabled: false

  # POSTGRESQL (R2DBC)
  r2dbc:
    url: r2dbc:postgresql://168.119.122.86:5432/yowyob
    username: master
    password: Azerty1234*

  sql:
    init:
      mode: always

  # REDIS CLUSTER 
  data:
    redis:
      password: Azerty1234*
      cluster:
        nodes:
          - 168.119.122.86:7001
          - 168.119.122.86:7002
          - 168.119.122.86:7003
          - 168.119.122.86:7004
          - 168.119.122.86:7005
          - 168.119.122.86:7006

  # KAFKA 
  kafka:
    bootstrap-servers: 168.119.122.86:9092
    consumer:
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# CUSTOM CONFIG 
application:
  external:
    stock-service-url: http://168.119.122.86:8081

  kafka:
    topics:
      product-events: test-topic

# RESILIENCE4J 
resilience4j:
  circuitbreaker:
    instances:
      stock-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        slidingWindowSize: 5


--- FILE: src/main/resources/application.yml ---
server:
  port: 8080

spring:
  application:
    name: reactive-hexagonal
    
  docker:
    compose:
      enabled: false

  # POSTGRESQL (R2DBC)
  r2dbc:
    url: r2dbc:postgresql://168.119.122.86:5432/yowyob
    username: master
    password: Azerty1234*

  sql:
    init:
      mode: always

  # REDIS CLUSTER 
  data:
    redis:
      host: 168.119.122.86
      port: 7000
      password: Azerty1234*
      cluster:
        enabled: false 

  # KAFKA 
  kafka:
    bootstrap-servers: 168.119.122.86:9092
    consumer:
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# CUSTOM CONFIG 
application:
  external:
    stock-service-url: http://168.119.122.86:8081

  kafka:
    topics:
      product-events: test-topic

# RESILIENCE4J 
resilience4j:
  circuitbreaker:
    instances:
      stock-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        slidingWindowSize: 5


--- FILE: src/main/resources/schema.sql ---
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

DROP TABLE IF EXISTS products CASCADE;

CREATE TABLE IF NOT EXISTS products (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255),
    price DECIMAL(10, 2),
    status VARCHAR(50)
);


--- FILE: src/test/java/com/yowyob/reactive_hexagonal/ReactiveHexagonalApplicationTests.java ---
package com.yowyob.reactive_hexagonal;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ReactiveHexagonalApplicationTests {

	@Test
	void contextLoads() {
	}

}

